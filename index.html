<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Project Tracker ‚Äî –ì–∞–Ω—Ç</title>
<style>
  :root{
    --bg:#f5f7fb;
    --card:#fff;
    --muted:#6b6f76;
    --accent:#4666ff;
    --success:#24b47e;
    --danger:#ff6b6b;
    --shadow: 0 6px 18px rgba(42,52,90,0.06);
  }
  *{box-sizing:border-box}
  body{
    background:var(--bg);
    font-family: Inter, Roboto, Arial, sans-serif;
    color:#222;
    margin:0;
    padding:28px;
    display:flex;
    justify-content:center;
  }
  .wrap{width:100%;max-width:1100px}
  header{
    display:flex;
    gap:12px;
    align-items:center;
    margin-bottom:18px;
  }
  header h1{margin:0;font-size:20px}
  header input[type="text"]{
    font-size:18px;padding:8px 10px;border-radius:8px;border:1px solid #e1e6f0;background:white;width:100%;
  }
  .topbar{display:flex;gap:10px;margin-bottom:12px;align-items:center}
  .card{background:var(--card);border-radius:12px;padding:12px;border:1px solid #eef2fb;box-shadow:var(--shadow);margin-bottom:14px}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button{background:var(--accent);color:white;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600}
  button.ghost{background:transparent;color:var(--accent);border:1px solid rgba(70,102,255,0.12)}
  button.warn{background:var(--danger)}
  .grid{display:grid;grid-template-columns:1fr 380px;gap:12px}
  @media (max-width:1000px){ .grid{grid-template-columns:1fr} }

  table{width:100%;border-collapse:collapse;font-size:14px}
  th,td{padding:8px;border-bottom:1px solid #f0f3fa;vertical-align:middle}
  th{background:#fbfcff;color:var(--muted);font-weight:700;text-align:left}
  .id{width:64px;color:#445; font-weight:700}
  input[type="date"], input[type="text"], select{padding:6px;border-radius:8px;border:1px solid #e6ebf8;background:white}
  .small{font-size:12px;color:var(--muted)}
  .center{text-align:center}
  .nowrap{white-space:nowrap}
  .priority-chip{display:inline-flex;gap:6px;align-items:center;padding:6px 8px;border-radius:999px;font-weight:600}
  .prio-high{background:#ffe8e8;color:#c33;border:1px solid rgba(255,107,107,0.12)}
  .prio-mid{background:#fff4e6;color:#c76b11;border:1px solid rgba(255,170,0,0.08)}
  .prio-low{background:#e9f9f0;color:#0a7a4a;border:1px solid rgba(36,180,126,0.08)}

  /* Gantt */
  .gantt-wrap{overflow:auto;padding:8px}
  .gantt-canvas{background:white;border-radius:10px;border:1px solid #eef2fb;padding:10px}
  .legend{display:flex;gap:8px;align-items:center;margin-top:8px}
  .legend .item{display:flex;gap:6px;align-items:center;font-size:13px;color:var(--muted)}
  .bar-rect{width:18px;height:10px;border-radius:4px;display:inline-block}

  .actions{display:flex;gap:8px;align-items:center;margin-left:auto}
  .muted{color:var(--muted)}
</style>
</head>
<body>
  <div class="wrap">
    <header style="margin-bottom:8px">
      <input id="projectTitle" type="text" value="–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞" />
    </header>

    <div class="card topbar" style="align-items:flex-start">
      <div style="flex:1">
        <div style="display:flex;gap:8px;align-items:center">
          <input id="taskName" type="text" placeholder="–ù–æ–≤–∞—è –∑–∞–¥–∞—á–∞ ‚Äî –Ω–∞–∑–≤–∞–Ω–∏–µ" style="flex:1"/>
          <input id="taskStart" type="date" />
          <input id="taskEnd" type="date" />
          <input id="taskDepends" type="text" placeholder="Depends (ID –∏–ª–∏ –∏–º—è)" style="width:130px"/>
          <select id="taskPriority">
            <option value="–í—ã—Å–æ–∫–∏–π">üî• –í—ã—Å–æ–∫–∏–π</option>
            <option value="–°—Ä–µ–¥–Ω–∏–π" selected>‚ö†Ô∏è –°—Ä–µ–¥–Ω–∏–π</option>
            <option value="–ù–∏–∑–∫–∏–π">‚úÖ –ù–∏–∑–∫–∏–π</option>
          </select>
          <input id="taskOwner" type="text" placeholder="–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π" style="width:120px"/>
          <select id="taskStatus">
            <option>–ù–µ –Ω–∞—á–∞—Ç–æ</option><option>–í —Ä–∞–±–æ—Ç–µ</option><option>–û–∂–∏–¥–∞–Ω–∏–µ</option><option>–ì–æ—Ç–æ–≤–æ</option>
          </select>
          <button onclick="addTask()">–î–æ–±–∞–≤–∏—Ç—å</button>
        </div>
        <div class="small" style="margin-top:8px">–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç—å: —É–∫–∞–∑—ã–≤–∞–π <strong>ID</strong> (A1, A2...) –∏–ª–∏ —Ç–æ—á–Ω–æ–µ –∏–º—è –ø—Ä–µ–¥—à–µ—Å—Ç–≤–µ–Ω–Ω–∏–∫–∞. –ï—Å–ª–∏ –∑–∞–¥–∞—á–∞ –∑–∞–≤–∏—Å–∏—Ç ‚Äî –µ—ë <em>Start</em> –±—É–¥–µ—Ç —Ä–∞–≤–µ–Ω <em>End</em> –ø—Ä–µ–¥—à–µ—Å—Ç–≤–µ–Ω–Ω–∏–∫–∞.</div>
      </div>

      <div class="actions">
        <button class="ghost" onclick="downloadCSV()">–≠–∫—Å–ø–æ—Ä—Ç CSV</button>
        <button class="ghost" onclick="importCSVPrompt()">–ò–º–ø–æ—Ä—Ç CSV</button>
        <button class="ghost" onclick="clearAll()">–û—á–∏—Å—Ç–∏—Ç—å</button>
      </div>
    </div>

    <div class="grid">
      <!-- left: table -->
      <div class="card">
        <table id="tasksTable" role="grid">
          <thead>
            <tr>
              <th class="id">ID</th>
              <th>–ó–∞–¥–∞—á–∞</th>
              <th>Start</th>
              <th>End</th>
              <th>Depends</th>
              <th>Override</th>
              <th>–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç</th>
              <th>–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π</th>
              <th>–°—Ç–∞—Ç—É—Å</th>
              <th class="center">–î–µ–π—Å—Ç–≤–∏—è</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <div style="margin-top:8px" class="small muted">–ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ: LocalStorage. –ü–æ—Å–ª–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è ‚Äî –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –∏ —Ä–µ—Ñ—Ä–µ—à–∞—Ç –¥–∏–∞–≥—Ä–∞–º–º—É.</div>
      </div>

      <!-- right: gantt -->
      <div>
        <div class="card">
          <div style="display:flex;align-items:center;justify-content:space-between">
            <div><strong>–î–∏–∞–≥—Ä–∞–º–º–∞ –ì–∞–Ω—Ç–∞</strong></div>
            <div class="small muted">–ú–∞—Å—à—Ç–∞–± –ø–æ –¥–Ω—è–º. –û–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.</div>
          </div>
          <div class="gantt-wrap" style="margin-top:10px">
            <div class="gantt-canvas">
              <canvas id="ganttCanvas" width="820" height="360" style="width:100%;height:360px;display:block"></canvas>
            </div>
            <div class="legend">
              <div class="item"><span class="bar-rect" style="background:#4666ff"></span> –ó–∞–¥–∞—á–∞</div>
              <div class="item"><span class="bar-rect" style="background:#2db47e"></span> –ì–æ—Ç–æ–≤–æ</div>
              <div class="item"><span class="bar-rect" style="background:#ff6b6b"></span> –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ</div>
            </div>
          </div>
        </div>

        <div style="height:12px"></div>
        <div class="card small muted">–°–æ–≤–µ—Ç: –∏—Å–ø–æ–ª—å–∑—É–π ID A1, A2... ‚Äî –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –æ–Ω–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.</div>
      </div>
    </div>
  </div>

<script>
/* ======== Data model and storage ======== */
const STORAGE_KEY = "project.tracker.v2";
let tasks = []; // {id, name, start, end, depends, override (bool), priority, owner, status}
const defaultDurationDays = 3; // used when end missing: end = start + (defaultDurationDays - 1)

/* utils */
const fmt = d => d ? new Date(d).toISOString().slice(0,10) : "";
const parse = s => {
  if(!s) return null;
  const t = new Date(s + "T00:00:00");
  return isNaN(t) ? null : t;
};
const addDays = (d, n) => { const x = new Date(d); x.setDate(x.getDate() + n); return x; };
const daysBetween = (a,b) => Math.round((b - a) / (24*3600*1000));

function save(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks));
  render();
}
function load(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if(raw){
    try{ tasks = JSON.parse(raw) } catch(e){ tasks = []; }
  } else {
    // sample initial
    tasks = [
      {id:"A1", name:"–û–±–º–µ—Ä", start:fmt(new Date()), end:fmt(addDays(new Date(),2)), depends:"", override:false, priority:"–í—ã—Å–æ–∫–∏–π", owner:"–ê–ª–∏—Å–∞", status:"–í —Ä–∞–±–æ—Ç–µ"},
      {id:"A2", name:"–ü–ª–∞–Ω–∏—Ä–æ–≤–∫–∏", start:"", end:"", depends:"A1", override:false, priority:"–°—Ä–µ–¥–Ω–∏–π", owner:"–°–∞—à–∞", status:"–ù–µ –Ω–∞—á–∞—Ç–æ"},
      {id:"A3", name:"–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏", start:"", end:"", depends:"A2", override:false, priority:"–ù–∏–∑–∫–∏–π", owner:"–û–ª—è", status:"–ù–µ –Ω–∞—á–∞—Ç–æ"}
    ];
    save();
  }
}

/* ========= Core: dependency resolution =========
 Rules:
  - If task.depends references a task (by id or exact name) and override==false:
      task.start := predecessor.end (same day)
  - If task.start exists and task.end missing -> end = start + (defaultDurationDays-1)
  - If end < start -> end = start
  - Repeat iteratively until stable (max passes = tasks.length+5)
*/
function resolveDependencies(){
  const map = {};
  tasks.forEach(t => map[t.id] = t);
  // also allow lookup by name
  tasks.forEach(t => map[t.name] = t);

  // initialize dates as Date objects for computation
  tasks.forEach(t => {
    t._start = parse(t.start);
    t._end = parse(t.end);
  });

  let changed = true;
  let passes = 0;
  const maxPasses = tasks.length + 5;

  while(changed && passes < maxPasses){
    changed = false;
    passes++;
    for(const t of tasks){
      // if depends and predecessor exists and not override -> set start = pred.end
      if(t.depends && !t.override){
        const pred = map[t.depends];
        if(pred && parse(pred.end)){
          const predEndDate = parse(pred.end);
          // rule: dependent start = pred.end (same day)
          const desiredStart = fmt(predEndDate);
          if(t.start !== desiredStart){
            t.start = desiredStart;
            t._start = parse(t.start);
            changed = true;
          }
          // if no end or end < start -> set end = start + defaultDuration-1
          if(!t.end || parse(t.end) < t._start){
            const newEnd = fmt(addDays(t._start, defaultDurationDays - 1));
            if(t.end !== newEnd){
              t.end = newEnd; t._end = parse(t.end); changed = true;
            }
          }
        }
      } else {
        // no depends or override: if start exists and end missing -> create end
        if(t.start && (!t.end || parse(t.end) < parse(t.start))){
          const s = parse(t.start);
          if(s){
            const newEnd = fmt(addDays(s, defaultDurationDays - 1));
            if(t.end !== newEnd){
              t.end = newEnd; t._end = parse(t.end); changed = true;
            }
          }
        }
      }
    }
  }

  // final normalization: ensure strings are formatted
  tasks.forEach(t=>{
    t.start = fmt(parse(t.start)) || "";
    t.end = fmt(parse(t.end)) || "";
  });
}

/* ========= UI Rendering ========= */
function render(){
  resolveDependencies();
  const tbody = document.querySelector("#tasksTable tbody");
  tbody.innerHTML = "";
  for(const t of tasks){
    const tr = document.createElement("tr");

    // id
    const tdId = document.createElement("td"); tdId.className="id"; tdId.textContent = t.id; tr.appendChild(tdId);

    // name
    const tdName = document.createElement("td");
    const inpName = document.createElement("input"); inpName.type="text"; inpName.value = t.name;
    inpName.onchange = () => { t.name = inpName.value.trim(); save(); };
    tdName.appendChild(inpName); tr.appendChild(tdName);

    // start
    const tdStart = document.createElement("td");
    const inStart = document.createElement("input"); inStart.type="date"; inStart.value = t.start || "";
    inStart.onchange = () => { t.start = inStart.value || ""; save(); };
    tdStart.appendChild(inStart); tr.appendChild(tdStart);

    // end
    const tdEnd = document.createElement("td");
    const inEnd = document.createElement("input"); inEnd.type="date"; inEnd.value = t.end || "";
    inEnd.onchange = () => { t.end = inEnd.value || ""; save(); };
    tdEnd.appendChild(inEnd); tr.appendChild(tdEnd);

    // depends
    const tdDep = document.createElement("td");
    const inDep = document.createElement("input"); inDep.type="text"; inDep.value = t.depends || "";
    inDep.placeholder = "A1 –∏–ª–∏ —Ç–æ—á–Ω–æ–µ –∏–º—è";
    inDep.onchange = () => { t.depends = inDep.value.trim(); save(); };
    tdDep.appendChild(inDep); tr.appendChild(tdDep);

    // override
    const tdOv = document.createElement("td"); tdOv.className="center";
    const chk = document.createElement("input"); chk.type="checkbox"; chk.checked = !!t.override;
    chk.onchange = () => { t.override = chk.checked; save(); };
    tdOv.appendChild(chk); tr.appendChild(tdOv);

    // priority
    const tdPr = document.createElement("td");
    const selPr = document.createElement("select");
    [["–í—ã—Å–æ–∫–∏–π","üî• –í—ã—Å–æ–∫–∏–π"],["–°—Ä–µ–¥–Ω–∏–π","‚ö†Ô∏è –°—Ä–µ–¥–Ω–∏–π"],["–ù–∏–∑–∫–∏–π","‚úÖ –ù–∏–∑–∫–∏–π"]].forEach(([val,lab])=>{
      const o = document.createElement("option"); o.value = val; o.textContent = lab;
      if(t.priority === val) o.selected = true;
      selPr.appendChild(o);
    });
    selPr.onchange = ()=>{ t.priority = selPr.value; save(); };
    tdPr.appendChild(selPr); tr.appendChild(tdPr);

    // owner
    const tdOwn = document.createElement("td");
    const inOwn = document.createElement("input"); inOwn.type="text"; inOwn.value = t.owner || "";
    inOwn.onchange = ()=>{ t.owner = inOwn.value; save(); };
    tdOwn.appendChild(inOwn); tr.appendChild(tdOwn);

    // status
    const tdSt = document.createElement("td");
    const selSt = document.createElement("select");
    ["–ù–µ –Ω–∞—á–∞—Ç–æ","–í —Ä–∞–±–æ—Ç–µ","–û–∂–∏–¥–∞–Ω–∏–µ","–ì–æ—Ç–æ–≤–æ","–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ"].forEach(s=>{
      const o = document.createElement("option"); o.value = s; o.textContent = s;
      if(t.status === s) o.selected = true;
      selSt.appendChild(o);
    });
    selSt.onchange = ()=>{ t.status = selSt.value; save(); };
    tdSt.appendChild(selSt); tr.appendChild(tdSt);

    // actions
    const tdAct = document.createElement("td"); tdAct.className="center";
    const btnUp = document.createElement("button"); btnUp.className="ghost"; btnUp.style.padding="6px 8px"; btnUp.textContent="‚Üë"; btnUp.title="–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤–≤–µ—Ä—Ö";
    btnUp.onclick = ()=>{ moveTask(t.id, -1); };
    const btnDown = document.createElement("button"); btnDown.className="ghost"; btnDown.style.padding="6px 8px"; btnDown.textContent="‚Üì"; btnDown.title="–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤–Ω–∏–∑";
    btnDown.onclick = ()=>{ moveTask(t.id, 1); };
    const btnDel = document.createElement("button"); btnDel.style.marginLeft="6px"; btnDel.textContent="–£–¥–∞–ª–∏—Ç—å"; btnDel.onclick = ()=>{ if(confirm('–£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É '+t.id+'?')){ removeTask(t.id); } };
    tdAct.appendChild(btnUp); tdAct.appendChild(btnDown); tdAct.appendChild(btnDel);
    tr.appendChild(tdAct);

    tbody.appendChild(tr);
  }

  document.getElementById("projectTitle").value = document.getElementById("projectTitle").value || "–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞";
  drawGantt();
}

/* ========= CRUD helpers ========= */
function genId(){
  // A1, A2, ...
  let n = 1;
  while(tasks.some(t => t.id === `A${n}`)) n++;
  return `A${n}`;
}
function addTask(){
  const name = document.getElementById("taskName").value.trim() || `–ù–æ–≤–∞—è –∑–∞–¥–∞—á–∞ ${tasks.length+1}`;
  const start = document.getElementById("taskStart").value || "";
  const end = document.getElementById("taskEnd").value || "";
  const depends = document.getElementById("taskDepends").value.trim() || "";
  const priority = document.getElementById("taskPriority").value;
  const owner = document.getElementById("taskOwner").value.trim() || "";
  const status = document.getElementById("taskStatus").value;
  const obj = { id: genId(), name, start, end, depends, override: false, priority, owner, status };
  tasks.push(obj);
  // clear fields
  document.getElementById("taskName").value = "";
  document.getElementById("taskStart").value = "";
  document.getElementById("taskEnd").value = "";
  document.getElementById("taskDepends").value = "";
  document.getElementById("taskOwner").value = "";
  save();
}
function removeTask(id){
  tasks = tasks.filter(t=> t.id !== id);
  // also clear depends that reference it
  tasks.forEach(t=>{ if(t.depends === id) t.depends = ""; });
  save();
}
function moveTask(id, dir){
  const idx = tasks.findIndex(t => t.id === id);
  if(idx < 0) return;
  const to = idx + dir;
  if(to < 0 || to >= tasks.length) return;
  const tmp = tasks[to]; tasks[to] = tasks[idx]; tasks[idx] = tmp;
  save();
}
function clearAll(){
  if(confirm("–£–¥–∞–ª–∏—Ç—å –≤—Å–µ –∑–∞–¥–∞—á–∏?")){ tasks = []; save(); }
}

/* ========= CSV export/import (simple) ========= */
function downloadCSV(){
  const header = ["ID","Name","Start","End","Depends","Override","Priority","Owner","Status"];
  const rows = tasks.map(t => [
    t.id, `"${(t.name||"").replace(/"/g,'""')}"`, t.start||"", t.end||"", `"${(t.depends||"").replace(/"/g,'""')}"`, t.override? "1":"0", t.priority||"", t.owner||"", t.status||""
  ]);
  const txt = [header.join(","), ...rows.map(r=> r.join(","))].join("\n");
  const blob = new Blob([txt], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href = url; a.download = "tasks.csv"; a.click(); URL.revokeObjectURL(url);
}
function importCSVPrompt(){
  const inp = document.createElement("input"); inp.type="file"; inp.accept=".csv";
  inp.onchange = e=>{
    const f = e.target.files[0]; if(!f) return;
    const r = new FileReader();
    r.onload = ev => {
      try{
        parseCSV(ev.target.result);
        save();
      }catch(err){
        alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ: " + err);
      }
    };
    r.readAsText(f,"utf-8");
  };
  inp.click();
}
function parseCSV(text){
  const lines = text.split(/\r?\n/).filter(Boolean);
  if(lines.length < 2) throw "CSV –ø—É—Å—Ç –∏–ª–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω";
  const hdr = lines[0].split(",").map(h=>h.trim());
  const newTasks = [];
  for(let i=1;i<lines.length;i++){
    const cols = csvSplit(lines[i]);
    if(cols.length < 5) continue;
    const t = {
      id: cols[0] || genId(),
      name: cols[1] ? cols[1].replace(/^"|"$/g,"").replace(/""/g,'"') : "",
      start: cols[2] || "",
      end: cols[3] || "",
      depends: cols[4] ? cols[4].replace(/^"|"$/g,"").replace(/""/g,'"') : "",
      override: (cols[5]||"") === "1",
      priority: cols[6] || "–°—Ä–µ–¥–Ω–∏–π",
      owner: cols[7] || "",
      status: cols[8] || "–ù–µ –Ω–∞—á–∞—Ç–æ"
    };
    newTasks.push(t);
  }
  tasks = newTasks;
}
function csvSplit(line){
  const out=[]; let cur=""; let q=false;
  for(let i=0;i<line.length;i++){
    const ch=line[i];
    if(ch === '"'){ if(q && line[i+1]==='"'){ cur+='"'; i++; } else q=!q; continue; }
    if(ch === ',' && !q){ out.push(cur); cur=""; continue; }
    cur+=ch;
  }
  out.push(cur);
  return out;
}

/* ========= GANTT drawing ========= */
function drawGantt(){
  resolveDependencies(); // ensure dates are up-to-date
  const canvas = document.getElementById("ganttCanvas");
  const ctx = canvas.getContext("2d");
  // adapt canvas pixel size to container width
  const containerWidth = canvas.clientWidth;
  canvas.width = Math.max(600, Math.floor(containerWidth));
  // size
  const width = canvas.width, height = canvas.height = 360;
  ctx.clearRect(0,0,width,height);
  // collect date range
  const validTasks = tasks.filter(t=> parse(t.start) !== null && parse(t.end) !== null);
  if(validTasks.length === 0){
    ctx.fillStyle = "#666"; ctx.font = "14px Arial"; ctx.fillText("–ù–µ—Ç –∑–∞–¥–∞—á —Å –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–º–∏ –¥–∞—Ç–∞–º–∏ –¥–ª—è –ø–æ–∫–∞–∑–∞ –ì–∞–Ω—Ç–∞", 20, 24); return;
  }
  let minDate = parse(validTasks[0].start), maxDate = parse(validTasks[0].end);
  validTasks.forEach(t=>{
    const s = parse(t.start), e = parse(t.end);
    if(!s || !e) return;
    if(s < minDate) minDate = s;
    if(e > maxDate) maxDate = e;
  });
  // pad range by 1 day each side
  minDate = addDays(minDate, -1);
  maxDate = addDays(maxDate, 1);
  const totalDays = daysBetween(minDate, maxDate) + 1;
  const leftPadding = 140;
  const rightPadding = 30;
  const usableWidth = width - leftPadding - rightPadding;
  const pxPerDay = Math.max(8, usableWidth / Math.max(1,totalDays)); // min width per day

  // draw grid header (dates)
  ctx.font = "12px Arial";
  ctx.fillStyle = "#111";
  // top header background
  ctx.fillStyle = "#fafbff";
  ctx.fillRect(leftPadding, 0, usableWidth, 28);
  ctx.fillStyle = "#666";
  for(let d=0; d<= totalDays; d++){
    const cur = addDays(minDate, d);
    const x = leftPadding + Math.round(d * pxPerDay);
    // vertical grid line
    ctx.strokeStyle = "#f0f2f7";
    ctx.beginPath(); ctx.moveTo(x + 0.5, 28); ctx.lineTo(x + 0.5, height - 10); ctx.stroke();
    // date label every ~2-3 days depending on zoom
    if(pxPerDay > 14 || d % Math.max(1, Math.ceil(3 / (pxPerDay/8))) === 0){
      ctx.fillStyle = "#333";
      ctx.fillText(cur.toISOString().slice(0,10), x + 2, 18);
    }
  }

  // draw rows and bars
  const rowHeight = 36;
  validTasks.forEach((t, idx)=>{
    const y = 36 + idx * rowHeight;
    // label area
    ctx.fillStyle = "#111";
    ctx.font = "13px Arial";
    ctx.fillText(`${t.id} ${t.name}`, 8, y + 14);

    // draw background row
    ctx.fillStyle = idx % 2 === 0 ? "#ffffff" : "#fbfcff";
    ctx.fillRect(leftPadding, y, usableWidth, rowHeight - 6);

    // compute positions
    const s = parse(t.start), e = parse(t.end);
    if(!s || !e) return;
    const startOffset = daysBetween(minDate, s);
    const dur = daysBetween(s, e) + 1;
    const x = leftPadding + Math.round(startOffset * pxPerDay);
    const w = Math.max(6, Math.round(dur * pxPerDay));

    // color by status / priority
    let color = "#4666ff";
    if(t.status === "–ì–æ—Ç–æ–≤–æ") color = "#2db47e";
    if(t.status === "–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ") color = "#ff6b6b";
    // draw bar
    ctx.fillStyle = color;
    roundRect(ctx, x+2, y+6, w-4, 22, 6, true, false);
    // label inside bar (if wide)
    ctx.fillStyle = "#fff";
    ctx.font = "12px Arial";
    if(w > 60){
      ctx.fillText(t.name, x + 10, y + 20);
    } else {
      // small, draw name left
      ctx.fillStyle = "#333";
      ctx.fillText(t.name, x + w + 6, y + 18);
    }
  });

  // helper draw border
  ctx.strokeStyle = "#e9eefb";
  ctx.strokeRect(leftPadding, 28, usableWidth, validTasks.length * rowHeight);

  // small utility for rounded rect
  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    if(w < 2 * r) r = w / 2;
    if(h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
    if(fill){ ctx.fill(); }
    if(stroke){ ctx.stroke(); }
  }
}

/* ========== init ========== */
document.getElementById("projectTitle").addEventListener("change", () => {
  localStorage.setItem("project.title", document.getElementById("projectTitle").value);
});
function loadTitle(){
  const t = localStorage.getItem("project.title");
  if(t) document.getElementById("projectTitle").value = t;
}

/* boot */
loadTitle();
load();
render();

/* expose for debug */
window.tracker = { tasks, save, load, render, drawGantt };
</script>
</body>
</html>
